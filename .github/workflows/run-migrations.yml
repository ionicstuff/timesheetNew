name: DB Migrations

on:
  workflow_dispatch:
    inputs:
      migration:
        description: 'Which migration script to run (apply or baseline)'
        required: false
        default: 'apply'
  push:
    branches: ["master"]
    paths:
      - "backend/**"
      - "infra/**"
      - ".github/workflows/run-migrations.yml"

jobs:
  run-migration:
    runs-on: ubuntu-latest
    env:
      AWS_REGION: ap-south-1
      CLUSTER: myapp-cluster
      TASK_DEFINITION: myapp-task                  # task family or ARN to run (can be name or ARN)
      CONTAINER: myapp-container
      SUBNETS: (subnet-0edf2dbee72fe373b,subnet-018e2886e7ca1a98d,subnet-0c0160cb1bfaba1cf)
      SECURITY_GROUPS: sg-0416d844a13f4199a
      DB_HOST: myapp-database.cl282y08qf6r.ap-south-1.rds.amazonaws.com
      DB_NAME: myapp_production
      DB_USER: myapp_user
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Choose migration command
        id: pick
        run: |
          # Workflow input chooses which migration script to run. Default is "apply".
          if [ "${{ github.event.inputs.migration }}" = "baseline" ]; then
            echo "migration_cmd=[\"node\",\"migrations/baseline.js\"]" >> "$GITHUB_OUTPUT"
          else
            echo "migration_cmd=[\"node\",\"migrations/apply.js\"]" >> "$GITHUB_OUTPUT"
          fi

      - name: Run migration task on ECS Fargate
        id: run-task
        run: |
          set -euo pipefail

          # Clean subnet / sg strings (allow the same notation used in deploy-backend.yml)
          SUBNETS_CLEAN=$(echo "$SUBNETS" | tr -d '() ' )
          SGS_CLEAN=$(echo "$SECURITY_GROUPS" | tr -d '() ' )

          # Verify subnets exist (optional; fails fast on typos)
          aws ec2 describe-subnets --subnet-ids $(echo "$SUBNETS_CLEAN" | tr ',' ' ') >/dev/null

          # Build network configuration JSON for aws cli
          NETCFG=$(jq -c -n --arg subs "$SUBNETS_CLEAN" --arg sgs "$SGS_CLEAN" '{
            awsvpcConfiguration: {
              subnets: ($subs | split(",")),
              securityGroups: ($sgs | split(",")),
              assignPublicIp: "DISABLED"
            }
          }')

          # Use chosen migration command (pick step writes a JSON array into outputs)
          MIGRATION_CMD='${{ steps.pick.outputs.migration_cmd }}'

          # Build overrides JSON including environment variables needed by migrations
          overrides=$(jq -c -n \
            --arg name "$CONTAINER" \
            --arg dbhost "$DB_HOST" \
            --arg dbname "$DB_NAME" \
            --arg dbuser "$DB_USER" \
            --arg nodeenv "production" \
            --argjson cmd "$MIGRATION_CMD" \
            '{
              containerOverrides:[{
                name: $name,
                command: $cmd,
                environment: [
                  {name:"NODE_ENV", value:$nodeenv},
                  {name:"DB_HOST", value:$dbhost},
                  {name:"DB_NAME", value:$dbname},
                  {name:"DB_USER", value:$dbuser}
                ]
              }]
            }')

          echo "Overrides: $overrides"
          echo "Network config: $NETCFG"

          # Run a one-off Fargate task
          TASK_ARN=$(aws ecs run-task \
            --cluster "$CLUSTER" \
            --launch-type FARGATE \
            --task-definition "$TASK_DEFINITION" \
            --network-configuration "$NETCFG" \
            --overrides "$overrides" \
            --query 'tasks[0].taskArn' --output text)

          if [ -z "$TASK_ARN" ] || [ "$TASK_ARN" = "None" ]; then
            echo "Failed to start ECS task" >&2
            exit 1
          fi

          echo "task_arn=$TASK_ARN" >> "$GITHUB_OUTPUT"
          echo "Started migration task: $TASK_ARN"

      - name: Wait for task to stop
        run: |
          aws ecs wait tasks-stopped --cluster "$CLUSTER" --tasks "${{ steps.run-task.outputs.task_arn }}"

      - name: Fetch logs (best-effort)
        run: |
          # Try to stream logs from CloudWatch (if your task is configured to send logs)
          TASK_ARN="${{ steps.run-task.outputs.task_arn }}"
          TASK_ID=$(basename "$TASK_ARN")
          # Attempt to find a log stream that contains the task id in its name
          LOG_STREAM=$(aws logs describe-log-streams --log-group-name "/ecs/${CONTAINER}" \
            --query 'logStreams[?contains(logStreamName, `'"$TASK_ID"'`)].logStreamName | [0]' --output text || true)
          if [ -n "$LOG_STREAM" ] && [ "$LOG_STREAM" != "None" ]; then
            echo "Fetching recent logs from $LOG_STREAM"
            aws logs get-log-events --log-group-name "/ecs/${CONTAINER}" --log-stream-name "$LOG_STREAM" --max-items 200 || true
          else
            echo "No log stream found for task $TASK_ID (this is best-effort)."
          fi

      - name: Check migration exit code and assert success
        run: |
          EXIT_CODE=$(aws ecs describe-tasks --cluster "$CLUSTER" --tasks "${{ steps.run-task.outputs.task_arn }}" \
            --query "tasks[0].containers[?name=='$CONTAINER'].exitCode | [0]" --output text)
          echo "Migration exit code: $EXIT_CODE"
          if [ "$EXIT_CODE" = "None" ] || [ -z "$EXIT_CODE" ]; then
            echo "Could not determine exit code; failing to be safe." >&2
            exit 1
          fi
          if [ "$EXIT_CODE" -ne 0 ]; then
            echo "Migration task failed with exit code $EXIT_CODE" >&2
            exit $EXIT_CODE
          fi

      - name: Done
        run: echo "Migration completed successfully"